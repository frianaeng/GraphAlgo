{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "2f737dd4-1fa7-44cb-8a00-345a8772596c",
   "metadata": {},
   "outputs": [],
   "source": [
    "from collections import defaultdict\n",
    "import pickle\n",
    "import os\n",
    "\n",
    "class MovieNetwork:\n",
    "    def __init__(self):\n",
    "        \"\"\"Creates a movie similarity network\"\"\"\n",
    "        # adjacency: movie -> {other_movie : weight}\n",
    "        self.adjacency = defaultdict(dict)\n",
    "        self.features = {}\n",
    "\n",
    "    def getNumMovies(self):\n",
    "        return len(self.adjacency)\n",
    "\n",
    "    def getNumEdges(self):\n",
    "        numEdges = 0\n",
    "        for _, nbrs in self.adjacency.items():\n",
    "            numEdges += len(nbrs)\n",
    "        return int(numEdges / 2)\n",
    "\n",
    "    def addMovie(self, movie, feature_set):\n",
    "        \"\"\"Add a movie and its feature set\"\"\"\n",
    "        if movie not in self.adjacency:\n",
    "            self.adjacency[movie] = {}\n",
    "        self.features[movie] = set(feature_set)\n",
    "\n",
    "    def addEdge(self, movie1, movie2, weight):\n",
    "        \"\"\"Add an undirected weighted edge\"\"\"\n",
    "        self.adjacency[movie1][movie2] = weight\n",
    "        self.adjacency[movie2][movie1] = weight\n",
    "\n",
    "\n",
    "    def jaccard(self, s1, s2):\n",
    "        if len(s1 | s2) == 0:\n",
    "            return 0.0\n",
    "        return len(s1 & s2) / len(s1 | s2)\n",
    "\n",
    "    def buildEdges(self, threshold=0.0):\n",
    "        \"\"\"Compute Jaccard weights for all movie pairs\"\"\"\n",
    "        movies = list(self.features.keys())\n",
    "\n",
    "        for i in range(len(movies)):\n",
    "            for j in range(i + 1, len(movies)):\n",
    "                m1, m2 = movies[i], movies[j]\n",
    "                w = self.jaccard(self.features[m1], self.features[m2])\n",
    "                if w > threshold:\n",
    "                    self.addEdge(m1, m2, w)\n",
    "\n",
    "   \n",
    "\n",
    "    def BFS(self, start):\n",
    "        import queue\n",
    "        Q = queue.SimpleQueue()\n",
    "        Q.put(start)\n",
    "\n",
    "        visited = {m: False for m in self.adjacency}\n",
    "        parent  = {m: None  for m in self.adjacency}\n",
    "\n",
    "        visited[start] = True\n",
    "\n",
    "        while not Q.empty():\n",
    "            u = Q.get()\n",
    "            for v in self.adjacency[u]:\n",
    "                if not visited[v]:\n",
    "                    visited[v] = True\n",
    "                    parent[v] = u\n",
    "                    Q.put(v)\n",
    "        return parent\n",
    "\n",
    "    def countConnectedComponents(self):\n",
    "        visited = {m: False for m in self.adjacency}\n",
    "        components = 0\n",
    "\n",
    "        for movie in self.adjacency:\n",
    "            if not visited[movie]:\n",
    "                components += 1\n",
    "                stack = [movie]\n",
    "                visited[movie] = True\n",
    "\n",
    "                while stack:\n",
    "                    u = stack.pop()\n",
    "                    for v in self.adjacency[u]:\n",
    "                        if not visited[v]:\n",
    "                            visited[v] = True\n",
    "                            stack.append(v)\n",
    "        return components\n",
    "\n",
    "    # -----------------------------\n",
    "    # Similarity-specific queries\n",
    "    # -----------------------------\n",
    "\n",
    "    def mostSimilar(self, movie, k=5):\n",
    "        \"\"\"Return top-k most similar movies\"\"\"\n",
    "        return sorted(\n",
    "            self.adjacency[movie].items(),\n",
    "            key=lambda x: x[1],\n",
    "            reverse=True\n",
    "        )[:k]\n",
    "\n",
    "    # -----------------------------\n",
    "    # Persistence\n",
    "    # -----------------------------\n",
    "\n",
    "    def save(self, path):\n",
    "        os.makedirs(os.path.dirname(path), exist_ok=True)\n",
    "        with open(path, \"wb\") as f:\n",
    "            pickle.dump(self, f)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "839047f8-010c-4299-989c-53e4ac2c930f",
   "metadata": {},
   "outputs": [],
   "source": [
    "#A very high Jaccard weight means the two movies share most of their features and are very similar under \n",
    "#the chosen feature set."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7314d15c-68f2-42ec-aade-c6738b6979a9",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:anaconda3]",
   "language": "python",
   "name": "conda-env-anaconda3-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
